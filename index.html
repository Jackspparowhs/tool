<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Color Finder — PirateRuler</title>
<meta name="theme-color" content="#f7fbff" />
<style>
  :root{
    --bg:#f3f7fb; --card:#fff; --muted:#6b7480; --text:#0b2130;
    --accent-start:#6b7dff; --accent-end:#0bb3ff; --shadow-sm:0 8px 24px rgba(3,12,30,0.08);
    --content-max:1280px;
  }
  html.theme-dark{--bg:#071225;--card:#061028;--muted:#98a7bf;--text:#e9f1ff;--accent-start:#5ab3ff;--accent-end:#6b7dff}
  html.theme-ocean{--bg:#e8f7fb;--card:#fff;--muted:#4f6b75;--text:#063242;--accent-start:#00c2d1;--accent-end:#2b9fff}
  html.theme-sunset{--bg:#fff6f8;--card:#fff;--muted:#7a6b77;--text:#2a1020;--accent-start:#ff7aa2;--accent-end:#ffb86b}

  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:linear-gradient(180deg,var(--bg),#e9f6ff);color:var(--text)}
  .wrap{max-width:var(--content-max);margin:14px auto;padding:18px}
  header{display:flex;align-items:center;justify-content:space-between;padding:14px;border-radius:14px;background:linear-gradient(90deg, rgba(107,125,255,0.06), rgba(11,179,255,0.02));box-shadow:var(--shadow-sm)}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent-start),var(--accent-end));display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900}
  .title-strong{font-weight:900;font-size:18px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .by{font-size:12px;color:var(--muted)}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{padding:9px 12px;border-radius:999px;border:none;cursor:pointer;font-weight:800}
  .btn.ghost{background:transparent;border:1px solid rgba(0,0,0,0.06)}
  .btn.theme{background:linear-gradient(90deg,var(--accent-start),var(--accent-end));color:#fff;box-shadow:0 8px 30px rgba(75,120,255,0.18)}
  main{display:grid;grid-template-columns:1fr 360px;gap:18px;margin-top:18px}
  @media(max-width:980px){ main{grid-template-columns:1fr} .right{position:relative;width:auto} }
  .card{background:var(--card);border-radius:14px;padding:18px;box-shadow:var(--shadow-sm);border:1px solid rgba(0,0,0,0.04)}
  .drop{min-height:260px;border-radius:12px;border:2px dashed rgba(0,0,0,0.06);display:flex;align-items:center;justify-content:center;padding:22px;text-align:center;color:var(--muted);cursor:pointer}
  input[type=file]{display:none}
  canvas{display:block;border-radius:12px;width:100%;height:auto;max-height:640px;object-fit:contain;background:transparent}
  .panel{padding:14px;border-radius:12px;background:var(--card);box-shadow:var(--shadow-sm)}
  .muted{color:var(--muted)}
  .palette{display:grid;gap:12px;margin-top:12px}
  .swatch{height:84px;border-radius:14px;display:flex;align-items:center;justify-content:space-between;padding:14px;color:var(--text);position:relative;overflow:hidden;border:1px solid rgba(0,0,0,0.04)}
  .sw-hex{font-weight:900}
  .sw-copy{padding:8px 12px;border-radius:999px;background:rgba(255,255,255,0.98);border:1px solid rgba(0,0,0,0.06);cursor:pointer}
  .info-grid{display:grid;gap:16px;margin-top:12px}
  @media(min-width:900px){ .info-grid{grid-template-columns:1fr 1fr} }
  footer{margin-top:18px;padding:14px;border-radius:12px;text-align:center;background:linear-gradient(180deg,rgba(255,255,255,0.92),rgba(255,255,255,0.96));box-shadow:var(--shadow-sm)}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">PR</div>
        <div>
          <div class="title-strong">Color Finder</div>
          <div class="by">by PirateRuler.com</div>
        </div>
      </div>
      <div class="controls">
        <button id="themeBtn" class="btn theme">Ocean ▾</button>
        <button id="openSidebarBtn" class="btn ghost">☰</button>
      </div>
    </header>

    <main>
      <section class="card">
        <h2 style="margin:0 0 8px 0">Extract colors from any image</h2>
        <p class="muted">Drop an image or pick a pixel. Everything happens in your browser — no upload.</p>

        <div id="dropZone" class="drop" title="Click or drop an image">
          <div id="dropInner">
            <div style="font-weight:900">Drop an image here or click to choose</div>
            <div class="muted" style="margin-top:6px">PNG / JPG / WEBP — processed locally.</div>
          </div>
        </div>
        <input id="fileInput" type="file" accept="image/*" />

        <div id="canvasWrap" class="card" style="margin-top:14px;display:none">
          <canvas id="imageCanvas" aria-label="Loaded image"></canvas>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
            <div class="muted small">Click image to pick a pixel.</div>
            <div style="display:flex;gap:8px">
              <button id="zoomIn" class="btn ghost">Zoom +</button>
              <button id="zoomOut" class="btn ghost">Zoom -</button>
              <button id="clear" class="btn ghost">Clear</button>
            </div>
          </div>
        </div>

        <div class="info-grid">
          <div class="card info">
            <h4 style="margin:0 0 6px 0">How it works</h4>
            <p class="muted" style="margin:0">The page samples pixels from your image and runs a small k-means on your device to find common colors. Click a swatch to copy the HEX code.</p>
          </div>
          <div class="card info">
            <h4 style="margin:0 0 6px 0">Privacy & Performance</h4>
            <p class="muted" style="margin:0">Images never leave your device — we use FileReader + canvas. Sampling is adaptive to keep mobile fast.</p>
          </div>
        </div>
      </section>

      <aside class="panel right">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <h3 style="margin:0">Palette</h3>
          <div style="width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent-start),var(--accent-end));display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900">PR</div>
        </div>

        <p class="muted" style="margin-top:8px">Extracted colors — click <strong>Copy</strong> to copy HEX.</p>

        <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
          <label class="muted">Colors</label>
          <input id="kRange" type="range" min="2" max="12" value="6" style="flex:1" />
          <div style="width:36px;text-align:center"><strong id="kValue">6</strong></div>
        </div>

        <div id="palette" class="palette" aria-live="polite"></div>

        <div style="display:flex;gap:8px;margin-top:12px">
          <button id="extractBtn" class="btn theme">Extract Palette</button>
          <button id="exportJSON" class="btn ghost">Export JSON</button>
          <button id="downloadPng" class="btn ghost">Download PNG</button>
          <button id="copyAll" class="btn ghost">Copy All</button>
        </div>
      </aside>
    </main>

    <footer>
      <small class="muted">© <span id="year"></span> PirateRuler — private & fast</small>
    </footer>
  </div>

<script>
document.getElementById('year').textContent = new Date().getFullYear();

/* THEMES - rotate */
const root = document.documentElement;
const themeBtn = document.getElementById('themeBtn');
const themes = ['theme-ocean','theme-light','theme-dark','theme-sunset'];
const names = {'theme-ocean':'Ocean','theme-light':'Light','theme-dark':'Dark','theme-sunset':'Sunset'};
let curTheme = localStorage.getItem('pr-theme') || 'theme-ocean';
applyTheme(curTheme);
themeBtn.addEventListener('click', ()=> {
  const idx = themes.indexOf(curTheme);
  curTheme = themes[(idx+1)%themes.length];
  applyTheme(curTheme);
  localStorage.setItem('pr-theme', curTheme);
});
function applyTheme(t){
  themes.forEach(x=>root.classList.remove(x));
  root.classList.add(t);
  themeBtn.textContent = (names[t]||'Ocean') + ' ▾';
}

/* SIDEBAR (simple toggle) */
const openSidebarBtn = document.getElementById('openSidebarBtn');
openSidebarBtn.addEventListener('click', ()=> {
  const sidebar = document.querySelector('#openSidebarBtn').dataset.open;
  const side = document.getElementById('sidebar');
  // we used fixed inline sidebar previously — this page uses a simple open/close -> just scroll
  // Keep it simple: show the right panel (already visible on desktop), on mobile scroll to it:
  document.querySelector('.right').scrollIntoView({behavior:'smooth'});
});

/* ELEMENTS */
const drop = document.getElementById('dropZone');
const fileIn = document.getElementById('fileInput');
const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently:true });
const canvasWrap = document.getElementById('canvasWrap');
const kRange = document.getElementById('kRange');
const kValue = document.getElementById('kValue');
const paletteEl = document.getElementById('palette');
const extractBtn = document.getElementById('extractBtn');
const exportJSON = document.getElementById('exportJSON');
const downloadPng = document.getElementById('downloadPng');
const clearBtn = document.getElementById('clear');
const zoomIn = document.getElementById('zoomIn');
const zoomOut = document.getElementById('zoomOut');
const copyAll = document.getElementById('copyAll');

let img = new Image();
let imgLoaded = false;
let scale = 1;
let lastPalette = [];

drop.addEventListener('click', ()=> fileIn.click());
drop.addEventListener('dragover', e=> { e.preventDefault(); drop.style.borderColor='rgba(0,0,0,0.12)'; });
drop.addEventListener('dragleave', e=> { e.preventDefault(); drop.style.borderColor=''; });
drop.addEventListener('drop', e=> { e.preventDefault(); const f = e.dataTransfer.files && e.dataTransfer.files[0]; if(f) handleFile(f); });
fileIn.addEventListener('change', e=> { if(e.target.files[0]) handleFile(e.target.files[0]); });

/* Robust file loader:
   - FileReader -> dataURL
   - try createImageBitmap (when available)
   - fallback to Image + await decode()
*/
async function handleFile(file){
  if(!file || !file.type || !file.type.startsWith('image/')) return alert('Choose an image file (PNG / JPG / WEBP).');

  const reader = new FileReader();
  reader.onload = async (ev) => {
    const dataUrl = ev.target.result;
    // Try createImageBitmap from blob (works better in some browsers)
    try {
      if(window.createImageBitmap){
        const blob = await (await fetch(dataUrl)).blob();
        const bitmap = await createImageBitmap(blob).catch(()=> null);
        if(bitmap){
          drawBitmap(bitmap);
          return;
        }
      }
    } catch(e){ console.warn('createImageBitmap failed', e); }
    // fallback: Image approach
    loadImageFromDataURL(dataUrl);
  };
  reader.onerror = ()=> alert('Failed to read file.');
  reader.readAsDataURL(file);
}

function drawBitmap(bitmap){
  try{
    imgLoaded = true;
    const maxW = Math.min(1200, window.innerWidth - 420);
    const maxH = 900;
    let w = bitmap.width, h = bitmap.height;
    const ratio = Math.min(1, maxW/w, maxH/h);
    w = Math.round(w * ratio); h = Math.round(h * ratio);
    scale = 1;
    canvas.width = w; canvas.height = h;
    ctx.clearRect(0,0,w,h);
    ctx.drawImage(bitmap, 0, 0, w, h);
    // keep a fallback image reference
    img = new Image();
    img.src = canvas.toDataURL('image/png');
    canvasWrap.style.display = 'block';
    setTimeout(()=> extractPalette(), 160);
  } catch(e){
    console.warn('drawBitmap error', e);
    alert('Could not draw image via bitmap.');
  }
}

async function loadImageFromDataURL(dataUrl){
  img = new Image();
  // do not set crossOrigin for data URLs — it can cause issues in some iOS builds
  try{
    img.src = dataUrl;
    if(img.decode) await img.decode(); // wait until fully decoded (better than onload in some browsers)
  }catch(e){
    // ignore; we'll also handle onload fallback
  }
  img.onload = ()=> {
    imgLoaded = true;
    const maxW = Math.min(1200, window.innerWidth - 420);
    const maxH = 900;
    let w = img.naturalWidth || img.width, h = img.naturalHeight || img.height;
    const ratio = Math.min(1, maxW/w, maxH/h);
    w = Math.round(w * ratio); h = Math.round(h * ratio);
    scale = 1;
    canvas.width = w; canvas.height = h;
    ctx.clearRect(0,0,w,h);
    try{ ctx.drawImage(img, 0, 0, w, h); }catch(e){ console.warn('drawImage failed', e); }
    canvasWrap.style.display = 'block';
    setTimeout(()=> extractPalette(), 160);
  };
  img.onerror = ()=> {
    alert('Could not load image (format unsupported or corrupt). Try re-saving as PNG/JPG and re-upload.');
  };
}

/* Zoom handlers */
zoomIn.addEventListener('click', ()=> { if(!imgLoaded) return; scale = Math.min(3, scale+0.25); resizeCanvas(); });
zoomOut.addEventListener('click', ()=> { if(!imgLoaded) return; scale = Math.max(0.5, scale-0.25); resizeCanvas(); });
function resizeCanvas(){
  if(!imgLoaded) return;
  const maxW = Math.min(1200, window.innerWidth - 420);
  const naturalW = img.naturalWidth || img.width || canvas.width;
  const naturalH = img.naturalHeight || img.height || canvas.height;
  const w = Math.round(Math.min(naturalW, maxW) * scale);
  const h = Math.round(w * (naturalH / naturalW));
  canvas.width = w; canvas.height = h;
  try{ ctx.clearRect(0,0,w,h); ctx.drawImage(img, 0, 0, w, h); }catch(e){ console.warn('resize draw failed', e); }
}

/* k-range UI */
kRange.addEventListener('input', ()=> kValue.textContent = kRange.value);
extractBtn.addEventListener('click', extractPalette);

/* extractPalette with stronger fallbacks */
function extractPalette(){
  if(!imgLoaded) return alert('Load an image first.');
  try{
    const w = canvas.width, h = canvas.height;
    const data = ctx.getImageData(0,0,w,h).data;
    const pixels = samplePixelsFromImageData(data, w, h);
    if(pixels.length === 0){
      // fallback 1: sample from a small thumbnail canvas (avoid strange alpha/size issues)
      const thumb = document.createElement('canvas');
      const tw = 200, th = Math.round((img.naturalHeight || img.height) * (tw / (img.naturalWidth || img.width)));
      thumb.width = tw; thumb.height = th || 200;
      const tctx = thumb.getContext('2d');
      try{
        tctx.drawImage(img, 0, 0, thumb.width, thumb.height);
        const tdata = tctx.getImageData(0,0,thumb.width, thumb.height).data;
        const tpixels = samplePixelsFromImageData(tdata, thumb.width, thumb.height);
        if(tpixels.length > 0) {
          performClustering(tpixels);
          return;
        }
      }catch(e){ console.warn('thumbnail fallback failed', e); }
      // fallback 2: tiny direct sampling from img (guaranteed some pixels)
      const raw = sampleSomePixelsDirectly(img, 12);
      if(raw.length > 0){
        performClustering(raw);
        return;
      }
      // final: give user guidance
      alert('No visible pixels found (image may be fully transparent or unsupported). Try re-saving the image as PNG/JPG and re-upload.');
      return;
    }
    performClustering(pixels);
  }catch(e){
    console.error('extractPalette error', e);
    alert('Failed to read image. If you are on iOS Safari, try saving the image as PNG/JPG and then upload.');
  }
}

/* helper to sample pixels from ImageData with simple alpha filter */
function samplePixelsFromImageData(data, w, h){
  const pixels = [];
  const targetSamples = 40000;
  const step = Math.max(1, Math.round(Math.sqrt((w*h)/targetSamples)));
  for(let y=0;y<h;y+=step){
    for(let x=0;x<w;x+=step){
      const i = (y*w + x)*4;
      const a = data[i+3]; // alpha 0-255
      if(a === 0) continue; // skip fully transparent only
      const r = data[i], g = data[i+1], b = data[i+2];
      pixels.push([r,g,b]);
    }
  }
  return pixels;
}

/* last-resort sampling: pick some pixels from image by drawing small canvas and reading center samples */
function sampleSomePixelsDirectly(image, count){
  try{
    const tmp = document.createElement('canvas');
    const tw = Math.min(128, image.naturalWidth || image.width || 128);
    const th = Math.min(128, image.naturalHeight || image.height || 128);
    tmp.width = tw; tmp.height = th;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(image, 0, 0, tw, th);
    const d = tctx.getImageData(0,0,tw,th).data;
    const res = [];
    for(let i=0;i<count;i++){
      const x = Math.floor((i+1)/(count+1) * (tw-1));
      const y = Math.floor((i+1)/(count+1) * (th-1));
      const idx = (y*tw + x)*4;
      const a = d[idx+3];
      if(a === 0) continue;
      res.push([d[idx], d[idx+1], d[idx+2]]);
    }
    return res;
  }catch(e){ console.warn('direct sample failed', e); return []; }
}

/* perform kmeans and render */
function performClustering(pixels){
  const k = Math.min(12, Math.max(2, parseInt(kRange.value,10) || 6));
  const {centroids, counts} = kmeans(pixels, k, {maxIter:30});
  let items = centroids.map((c,i)=>({rgb:c, count:counts[i]})).filter(Boolean);
  items = items.sort((a,b)=>b.count - a.count);
  lastPalette = items.map(it => {
    const hex = rgbToHex(...it.rgb);
    const pct = Math.round((it.count / pixels.length) * 100);
    return {hex, rgb: it.rgb, pct};
  });
  if(lastPalette.length === 0){
    // fallback: create palette from some pixels
    const fallback = pixels.slice(0, Math.min(6,pixels.length));
    lastPalette = fallback.map(px=>({hex: rgbToHex(px[0],px[1],px[2]), rgb:px, pct: Math.round(100/fallback.length)}));
  }
  renderPalette();
}

/* render palette UI */
function renderPalette(){
  paletteEl.innerHTML = '';
  lastPalette.forEach(p=>{
    const sw = document.createElement('div');
    sw.className = 'swatch';
    sw.style.background = p.hex;
    const textColor = getContrastColor(p.hex);
    sw.style.color = textColor;
    sw.innerHTML = `<div><div class="sw-hex">${p.hex}</div><div class="muted sw-pct">${p.pct}%</div></div>
      <div><button class="sw-copy" data-hex="${p.hex}">Copy</button></div>`;
    paletteEl.appendChild(sw);
  });
  paletteEl.querySelectorAll('.sw-copy').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      const hex = e.currentTarget.dataset.hex;
      navigator.clipboard.writeText(hex).then(()=> {
        const prev = e.currentTarget.textContent;
        e.currentTarget.textContent = 'Copied';
        setTimeout(()=> e.currentTarget.textContent = prev, 900);
      });
    });
  });
}

/* export / download / copy all */
document.getElementById('exportJSON').addEventListener('click', ()=>{
  if(!lastPalette.length) return alert('No palette to export.');
  const blob = new Blob([JSON.stringify({palette:lastPalette,createdAt:new Date().toISOString()},null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download='palette.json'; a.click(); URL.revokeObjectURL(url);
});
downloadPng.addEventListener('click', ()=>{
  if(!lastPalette.length) return alert('No palette to download.');
  const sw = Math.max(80, Math.floor(900/lastPalette.length)); const w = sw*lastPalette.length; const h = 160;
  const c = document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d');
  lastPalette.forEach((p,i)=>{ g.fillStyle=p.hex; g.fillRect(i*sw,0,sw,h); g.fillStyle=getContrastColor(p.hex); g.font='700 14px Inter, Arial'; g.textAlign='center'; g.fillText(p.hex, i*sw+sw/2, h-18); });
  const url = c.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='palette.png'; a.click();
});
copyAll.addEventListener('click', ()=> {
  if(!lastPalette.length) return;
  navigator.clipboard.writeText(lastPalette.map(p=>p.hex).join(', ')).then(()=> {
    const prev = copyAll.textContent; copyAll.textContent = 'Copied'; setTimeout(()=> copyAll.textContent = prev, 1200);
  });
});

/* single-pixel pick */
canvas.addEventListener('click', (e)=>{
  if(!imgLoaded) return;
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
  const y = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));
  try{
    const px = ctx.getImageData(x,y,1,1).data;
    const hex = rgbToHex(px[0],px[1],px[2]);
    lastPalette.unshift({hex, rgb:[px[0],px[1],px[2]], pct:1});
    const uniq = [];
    for(const it of lastPalette){ if(!uniq.some(u=>u.hex===it.hex)) uniq.push(it); if(uniq.length>=12) break; }
    lastPalette = uniq;
    renderPalette();
  }catch(e){ console.warn('pixel pick failed', e); }
});

/* clear */
clearBtn.addEventListener('click', ()=> {
  try{ ctx.clearRect(0,0,canvas.width,canvas.height); }catch(e){}
  canvas.width = canvas.height = 0; canvasWrap.style.display = 'none'; imgLoaded = false; lastPalette=[]; paletteEl.innerHTML=''; fileIn.value='';
});

/* helpers */
function getContrastColor(hex){
  const c = hex.replace('#',''); const r = parseInt(c.substr(0,2),16), g = parseInt(c.substr(2,2),16), b = parseInt(c.substr(4,2),16);
  const yiq = (r*299 + g*587 + b*114)/1000; return (yiq >= 150) ? '#111' : '#fff';
}
function componentToHex(c){ const s = c.toString(16); return s.length==1 ? '0'+s : s; }
function rgbToHex(r,g,b){ return '#'+componentToHex(r)+componentToHex(g)+componentToHex(b); }

/* kmeans (same robust impl) */
function kmeans(samples, k, opts={}) {
  const maxIter = opts.maxIter || 24;
  const centroids = []; const used = new Set();
  while(centroids.length < k && used.size < samples.length){
    const idx = Math.floor(Math.random()*samples.length);
    if(used.has(idx)) continue; used.add(idx); centroids.push(samples[idx].slice());
  }
  while(centroids.length < k) centroids.push(samples[Math.floor(Math.random()*samples.length)].slice());
  const assignments = new Array(samples.length).fill(-1);
  let counts = new Array(k).fill(0);
  for(let iter=0; iter<maxIter; iter++){
    let changed=false;
    for(let i=0;i<samples.length;i++){
      const s = samples[i];
      let best=0, bestd=dist2(s,centroids[0]);
      for(let j=1;j<k;j++){ const d=dist2(s,centroids[j]); if(d<bestd){bestd=d;best=j;} }
      if(assignments[i]!==best){ assignments[i]=best; changed=true; }
    }
    const sums = new Array(k).fill(0).map(()=>[0,0,0]); const cnts = new Array(k).fill(0);
    for(let i=0;i<samples.length;i++){ const a=assignments[i]; const s=samples[i]; sums[a][0]+=s[0]; sums[a][1]+=s[1]; sums[a][2]+=s[2]; cnts[a]++; }
    for(let j=0;j<k;j++){
      if(cnts[j]===0){ centroids[j]=samples[Math.floor(Math.random()*samples.length)].slice(); counts[j]=1; }
      else { centroids[j]=[Math.round(sums[j][0]/cnts[j]),Math.round(sums[j][1]/cnts[j]),Math.round(sums[j][2]/cnts[j])]; counts[j]=cnts[j]; }
    }
    if(!changed) break;
  }
  return {centroids, counts};
}
function dist2(a,b){ const dr=a[0]-b[0], dg=a[1]-b[1], db=a[2]-b[2]; return dr*dr+dg*dg+db*db; }

</script>
</body>
</html>
