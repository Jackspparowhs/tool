<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Internet Speed Checker — PirateRuler.com</title>
<meta name="description" content="Internet Speed Checker — PirateRuler.com — quick, browser-only speed checks with live readouts." />
<meta name="theme-color" content="#071225" />
<link rel="icon" href="https://pirateruler.com/static/pr-logo.png" type="image/png">
<link rel="apple-touch-icon" href="https://pirateruler.com/static/pr-logo.png">

<style>
  /* kept original design tokens and layout but content changed to Speed Test */
  :root{
    --space: 16px;
    --radius: 14px;
    --text-sans: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Helvetica Neue";
    --accent-a: #6b7dff;
    --accent-b: #7b4bff;
    --accent-c: #ff5aa4;
    --bg: linear-gradient(180deg,#061028 0%, #071225 50%);
    --card-dark: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    --glass: rgba(255,255,255,0.03);
    --muted: #98a7bf;
    --muted-2: rgba(233,241,255,0.14);
    --text: #e9f1ff;
    --radius-lg: 22px;
    --shadow-lg: 0 20px 50px rgba(2,8,20,0.6);
    --shadow-soft: 0 10px 30px rgba(2,8,20,0.35);
    --max-width: 1100px;
  }
  html.light {
    --bg: linear-gradient(180deg,#f7fbfe,#f3f7fb);
    --card-dark: linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.01));
    --glass: rgba(11,17,28,0.03);
    --muted: #6b7480;
    --muted-2: rgba(11,17,36,0.06);
    --text: #071225;
    --shadow-lg: 0 18px 50px rgba(3,12,30,0.06);
    --shadow-soft: 0 8px 24px rgba(3,12,30,0.06);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:var(--text-sans);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    color:var(--text);
    background:var(--bg);
    padding:var(--space);
    line-height:1.45;
  }
  a{color:inherit;text-decoration:none}
  .wrap{max-width:var(--max-width);margin:0 auto;padding-bottom:60px}
  header {display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px;border-radius:12px;background:transparent;margin-bottom:12px;}
  .brand {display:flex; gap:12px; align-items:center}
  .logo {width:56px;height:56px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,var(--accent-a),var(--accent-b)); color:white; font-weight:900; font-size:18px; box-shadow:var(--shadow-soft); flex-shrink:0;}
  .brand .title {font-weight:800; font-size:16px; margin-bottom:2px}
  .brand .sub {font-size:12px;color:var(--muted)}
  .controls {display:flex;gap:10px;align-items:center}
  .theme-btn{display:inline-flex;align-items:center;justify-content:center;padding:10px;border-radius:999px;background:var(--card-dark);border:0;width:48px;height:48px;box-shadow:var(--shadow-soft);cursor:pointer;color:var(--text);}
  .hamb {width:48px;height:48px;border-radius:12px; display:flex; align-items:center; justify-content:center;background:var(--card-dark); box-shadow:var(--shadow-soft); border:0; cursor:pointer; color:var(--text);}
  .hero {border-radius:18px;padding:18px 22px;background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:var(--shadow-lg);text-align:center;position:relative;overflow:visible;}
  .kicker {display:inline-block;padding:6px 12px;border-radius:999px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));color:var(--muted); font-weight:700;font-size:13px;margin-bottom:12px;}
  .h1 {font-size:28px;font-weight:900; margin:6px 0 8px; line-height:1.03; letter-spacing:-0.02em}
  .lead {max-width:920px;margin:0 auto;color:var(--muted); font-size:15px}
  .main-grid {display:grid;grid-template-columns:1fr 360px;gap:18px;margin-top:18px;align-items:start}
  @media(max-width:980px){ .main-grid{ grid-template-columns: 1fr } .h1{font-size:24px} }
  .panel {background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:14px; padding:18px; box-shadow:var(--shadow-soft)}
  .stat-row {display:flex;gap:12px;align-items:center;justify-content:center;margin-top:12px;flex-wrap:wrap}
  .big-m {font-size:44px;font-weight:900}
  .lbl {color:var(--muted);font-size:13px}
  .btn {background:linear-gradient(90deg,var(--accent-a),var(--accent-b));color:white;padding:12px 20px;border-radius:12px;border:0;font-weight:900;cursor:pointer}
  .btn-ghost {background:transparent;border:1px solid var(--muted-2); padding:10px 14px;border-radius:12px;color:var(--muted);font-weight:800}
  .right-col {position:relative}
  .mini-cta {display:block;margin-top:12px;padding:12px;border-radius:12px;background:linear-gradient(90deg,var(--accent-a),var(--accent-b));text-align:center;color:white;font-weight:900}
  footer {margin-top:18px;text-align:center}
  .meter {height:100px;width:100%;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));border-radius:12px;display:flex;align-items:center;justify-content:center;flex-direction:column}
  canvas#graph {width:100%;height:80px;background:transparent}
  .controls-row {display:flex;gap:12px;align-items:center;justify-content:center;margin-top:12px;flex-wrap:wrap}
  .small {font-size:12px;color:var(--muted)}
  .credit {position:relative;margin-top:10px;display:inline-block;padding:6px 12px;border-radius:10px;background:rgba(0,0,0,0.4);color:white}
  /* peak/arrow */
  .meta {display:flex;gap:10px;align-items:center;justify-content:center;margin-top:8px;flex-wrap:wrap}
  .meta .item {background:var(--card-dark);padding:8px 12px;border-radius:10px;font-weight:800;color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">PR</div>
        <div>
          <div class="title">Internet Speed Checker</div>
          <div class="sub">by PirateRuler.com — browser-first</div>
        </div>
      </div>

      <div class="controls" role="navigation" aria-label="Header controls">
        <button id="toggleTheme" class="theme-btn" title="Toggle theme">☀️</button>
        <button id="openMenu" class="hamb" aria-controls="menu" aria-expanded="false" title="Menu">☰</button>
      </div>
    </header>

    <section class="hero">
      <div class="kicker">Fast, privacy-first • Live readout</div>
      <div class="h1">Check your internet speed</div>
      <div class="lead">A lightweight client-side speed test. Measures download & upload throughput in your browser and updates live. For best results run on desktop and close other apps.</div>

      <div class="stat-row" style="margin-top:16px">
        <div class="panel" style="min-width:260px;flex:1">
          <div style="display:flex;align-items:center;justify-content:space-between;">
            <div>
              <div class="small lbl">Download</div>
              <div id="downloadValue" class="big-m">—</div>
              <div class="small lbl">Mbps</div>
            </div>
            <div style="width:48%;text-align:right">
              <div class="small lbl">Ping (est)</div>
              <div id="pingValue" style="font-weight:800;font-size:18px">— ms</div>
            </div>
          </div>
          <div style="margin-top:10px">
            <canvas id="downloadGraph" height="80"></canvas>
          </div>
          <div class="meta" id="downloadMeta">
            <div class="item small">avg: — Mbps</div>
            <div class="item small">curr: — Mbps</div>
          </div>
        </div>

        <div class="panel" style="min-width:260px;flex:1">
          <div style="display:flex;align-items:center;justify-content:space-between;">
            <div>
              <div class="small lbl">Upload</div>
              <div id="uploadValue" class="big-m">—</div>
              <div class="small lbl">Mbps</div>
            </div>
            <div style="width:48%;text-align:right">
              <div class="small lbl">Status</div>
              <div id="statusValue" style="font-weight:800;font-size:18px">Idle</div>
            </div>
          </div>
          <div style="margin-top:10px">
            <canvas id="uploadGraph" height="80"></canvas>
          </div>
          <div class="meta" id="uploadMeta">
            <div class="item small">avg: — Mbps</div>
            <div class="item small">curr: — Mbps</div>
          </div>
        </div>
      </div>

      <div class="controls-row">
        <button id="startBtn" class="btn">Start test</button>
        <button id="stopBtn" class="btn-ghost">Reset</button>
      </div>

      <div style="margin-top:12px" class="small">Note: this runs multiple downloads/uploads to estimate bandwidth. Results may vary slightly from third-party sites.</div>
    </section>

    <div class="main-grid" style="margin-top:12px">
      <div>
        <section class="panel">
          <h2 class="section">How this works</h2>
          <p class="small">The page downloads data from public test files and measures bytes/second using streaming APIs, then posts a large blob to an echo endpoint to measure upload throughput. Live graphs update every second. For best accuracy, close other network-heavy apps and test on wired connections where possible.</p>

          <div style="margin-top:12px">
            <h3 style="margin:6px 0">Advanced</h3>
            <ul class="small">
              <li>Parallel downloads: increases accuracy on high-speed links</li>
              <li>Progressive streaming: the test doesn't wait for entire file — it measures continuously</li>
              <li>Upload uses a POST to a public echo server (httpbin) — change to your own endpoint for better accuracy</li>
            </ul>
          </div>
        </section>
      </div>

      <aside class="right-col">
        <div class="panel">
          <h3 style="margin-top:0">Quick tips</h3>
          <ol class="small">
            <li>Run the test a few times — network conditions change.</li>
            <li>Prefer wired ethernet for accurate results.</li>
            <li>Use your own server for the best results (host CORS-enabled large files).</li>
          </ol>

          <div style="margin-top:10px">
            <div class="mini-cta" id="shareBtn">Copy results</div>
            <div style="height:8px"></div>
            <div class="small">Powered by PirateRuler.com — client-only demo</div>
          </div>
        </div>
      </aside>
    </div>

    <footer>
      <small class="credit" id="copyright">© <span id="year"></span> PirateRuler — Speed Checker</small>
    </footer>
  </div>

  <!-- menu -->
  <div id="menu" class="offcanvas" style="display:none;">
    <h3>Menu</h3>
    <a href="#">Home</a>
    <a href="#">Privacy</a>
    <a href="#">Contact</a>
    <div style="height:12px"></div>
    <button id="closeMenu" style="padding:10px;border-radius:10px;border:0;background:linear-gradient(90deg,#fff,#ddd);width:100%;font-weight:800">Close</button>
  </div>

<script>
/* ------------------------------
   Simple client-side speed test
   - Download: streaming approach using fetch + reader
   - Upload: XHR with generated blob and upload progress
   - Live per-second updates (Mbps)
   ------------------------------ */

document.getElementById('year').textContent = new Date().getFullYear();

// Theme/menu toggles (kept from original)
const docEl = document.documentElement;
const toggle = document.getElementById('toggleTheme');
const openMenu = document.getElementById('openMenu');
const menu = document.getElementById('menu');
const closeMenu = document.getElementById('closeMenu');
toggle.addEventListener('click', () => {
  if (docEl.classList.contains('light')) { docEl.classList.remove('light'); } else { docEl.classList.add('light'); }
});
openMenu.addEventListener('click', () => { menu.style.display='block'; menu.classList.add('open'); });
closeMenu && closeMenu.addEventListener('click', ()=>{ menu.style.display='none'; menu.classList.remove('open'); });

// DOM refs
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const downloadValue = document.getElementById('downloadValue');
const uploadValue = document.getElementById('uploadValue');
const statusValue = document.getElementById('statusValue');
const pingValue = document.getElementById('pingValue');
const downloadMeta = document.getElementById('downloadMeta');
const uploadMeta = document.getElementById('uploadMeta');
const shareBtn = document.getElementById('shareBtn');

// Graph canvases
const dcanvas = document.getElementById('downloadGraph');
const ucanvas = document.getElementById('uploadGraph');
const dctx = dcanvas.getContext('2d');
const uctx = ucanvas.getContext('2d');

function clearCanvas(ctx) {
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
}
function drawGraph(ctx, points, color) {
  const w = ctx.canvas.width = ctx.canvas.clientWidth;
  const h = ctx.canvas.height = ctx.canvas.clientHeight;
  ctx.clearRect(0,0,w,h);
  if (!points.length) return;
  const max = Math.max(...points, 1);
  ctx.beginPath();
  for (let i=0;i<points.length;i++){
    const x = (i/(points.length-1||1))*w;
    const y = h - (points[i]/max)*h;
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.lineWidth = 2.5;
  ctx.strokeStyle = color;
  ctx.stroke();
}

// Helpers: format Mbps
function toMbps(bytesPerSec) {
  return (bytesPerSec * 8) / (1024*1024);
}
function round2(v){ return Math.round(v*100)/100; }

// TEST CONFIG - tweakable
const DOWNLOAD_URLS = [
  // public test files — if CORS blocked swap to your own CORS-enabled files
  'https://speed.hetzner.de/100MB.bin',
  'https://speed.hetzner.de/100MB.bin'
];
const DOWNLOAD_PARALLEL = 2; // number of parallel fetches (<= DOWNLOAD_URLS.length)
const DOWNLOAD_WINDOW_SEC = 6; // measure for this many seconds
const UPLOAD_SIZE_MB = 8; // size of generated upload blob (MB)
const UPLOAD_URL = 'https://httpbin.org/post'; // public echo endpoint (CORS friendly usually)
let abortController = null;
let running = false;

// State arrays for graphs
let dPoints = [];
let uPoints = [];
let dSamples = []; // per-second bytes/sec samples (download)
let uSamples = []; // per-second bytes/sec samples (upload)
let downloadAvg = 0, uploadAvg = 0, lastPing = 0;

// measure ping via small fetch to google/dns; fallback to Date.now roundtrip
async function measurePing() {
  try {
    const t0 = performance.now();
    // try tiny file
    await fetch('https://www.google.com/generate_204', {method:'GET', cache:'no-store', mode:'no-cors'});
    const t1 = performance.now();
    return Math.round(t1 - t0);
  } catch(e){
    // fallback ping estimate using a small CORS endpoint (httpbin)
    try {
      const t0 = performance.now();
      await fetch('https://httpbin.org/get?rand='+Math.random(), {cache:'no-store'});
      const t1 = performance.now();
      return Math.round(t1 - t0);
    } catch(err) {
      return 999;
    }
  }
}

// DOWNLOAD: streaming reader that reports bytes per second
async function runDownloadTest() {
  const readerTasks = [];
  abortController = new AbortController();
  const signal = abortController.signal;

  dSamples = [];
  dPoints = [];
  downloadAvg = 0;
  downloadValue.textContent = '—';
  statusValue.textContent = 'Downloading...';
  statusValue.style.color = '';

  const perStreamProgress = Array(DOWNLOAD_PARALLEL).fill(0);

  // Start time
  const start = performance.now();

  // We'll track bytes read in the last second for live display
  let lastTotalBytes = 0;
  let totalBytes = 0;
  let lastTick = performance.now();

  // spawn parallel readers (limit by DOWNLOAD_PARALLEL)
  for (let i=0;i<DOWNLOAD_PARALLEL;i++){
    const url = DOWNLOAD_URLS[i % DOWNLOAD_URLS.length] + (i===0 ? '' : '?r='+Math.random());
    // Use fetch + reader
    const task = (async () => {
      try {
        const resp = await fetch(url, {cache:'no-store', signal});
        if (!resp.body) return;
        const reader = resp.body.getReader();
        while (true) {
          const {done, value} = await reader.read();
          if (done) break;
          totalBytes += value.byteLength;
          perStreamProgress[i] += value.byteLength;
          // Check window time — update per-second samples
          const now = performance.now();
          if (now - lastTick >= 1000) {
            const bytesThisSec = totalBytes - lastTotalBytes;
            lastTotalBytes = totalBytes;
            lastTick = now;
            dSamples.push(bytesThisSec);
            // limit samples to DOWNLOAD_WINDOW_SEC
            if (dSamples.length > DOWNLOAD_WINDOW_SEC) dSamples.shift();
            // compute current Mbps
            const currBps = bytesThisSec;
            const currMbps = toMbps(currBps);
            dPoints.push(currMbps);
            if (dPoints.length > 60) dPoints.shift();
            drawGraph(dctx,dPoints,'#6b7dff');
            downloadValue.textContent = round2(currMbps);
            // update meta
            const avg = toMbps( dSamples.reduce((a,b)=>a+b,0) / dSamples.length );
            downloadMeta.querySelector('.item') && (downloadMeta.querySelector('.item').textContent = 'avg: ' + round2(avg) + ' Mbps');
            downloadMeta.querySelectorAll('.item')[1] && (downloadMeta.querySelectorAll('.item')[1].textContent = 'curr: ' + round2(currMbps) + ' Mbps');
          }
        }
      } catch(err) {
        // aborted or network error
      }
    })();
    readerTasks.push(task);
  }

  // measure for DOWNLOAD_WINDOW_SEC seconds then stop
  const measureTimeout = new Promise(resolve => setTimeout(resolve, DOWNLOAD_WINDOW_SEC*1000));
  await Promise.race([ Promise.all(readerTasks), measureTimeout ]);
  // stop all fetches
  abortController && abortController.abort();
  // compute final average from samples
  const avgBps = dSamples.length ? (dSamples.reduce((a,b)=>a+b,0)/dSamples.length) : 0;
  downloadAvg = toMbps(avgBps);
  downloadValue.textContent = downloadAvg ? round2(downloadAvg) : '—';
  drawGraph(dctx,dPoints,'#6b7dff');
  downloadMeta.querySelector('.item') && (downloadMeta.querySelector('.item').textContent = 'avg: ' + (downloadAvg ? round2(downloadAvg) + ' Mbps' : '—'));
  statusValue.textContent = 'Download complete';
  return downloadAvg;
}

// UPLOAD: create a Blob and POST via XHR so we get progress events
function runUploadTest() {
  return new Promise((resolve, reject) => {
    // generate random blob of size UPLOAD_SIZE_MB
    const size = UPLOAD_SIZE_MB * 1024 * 1024;
    // It's faster to create a repeated pattern rather than truly random bytes
    const chunk = new Uint8Array(1024*1024).fill(0x61); // 1MB of 'a'
    const parts = [];
    for (let i=0;i<UPLOAD_SIZE_MB;i++) parts.push(chunk);
    const blob = new Blob(parts, {type:'application/octet-stream'});

    const xhr = new XMLHttpRequest();
    xhr.open('POST', UPLOAD_URL + '?r=' + Math.random(), true);
    xhr.responseType = 'json';

    let lastUploaded = 0;
    let lastTime = performance.now();
    uSamples = [];
    uPoints = [];

    xhr.upload.onprogress = function(e) {
      if (e.lengthComputable) {
        const uploaded = e.loaded;
        const now = performance.now();
        const dt = (now - lastTime) / 1000;
        if (dt >= 0.9) {
          const bytesThisSec = uploaded - lastUploaded;
          lastUploaded = uploaded;
          lastTime = now;
          uSamples.push(bytesThisSec);
          if (uSamples.length > 60) uSamples.shift();
          const currMbps = toMbps(bytesThisSec);
          uPoints.push(currMbps);
          if (uPoints.length > 60) uPoints.shift();
          drawGraph(uctx,uPoints,'#7b4bff');
          uploadValue.textContent = round2(currMbps);
          uploadMeta.querySelector('.item') && (uploadMeta.querySelector('.item').textContent = 'avg: ' + round2( toMbps(uSamples.reduce((a,b)=>a+b,0) / uSamples.length ) ) + ' Mbps');
          uploadMeta.querySelectorAll('.item')[1] && (uploadMeta.querySelectorAll('.item')[1].textContent = 'curr: ' + round2(currMbps) + ' Mbps');
        }
      }
    };
    xhr.onload = function() {
      if (xhr.status >= 200 && xhr.status < 300) {
        // final average
        const avgBps = uSamples.length ? (uSamples.reduce((a,b)=>a+b,0)/uSamples.length) : 0;
        uploadAvg = toMbps(avgBps);
        uploadValue.textContent = uploadAvg ? round2(uploadAvg) : '—';
        drawGraph(uctx,uPoints,'#7b4bff');
        statusValue.textContent = 'Upload complete';
        resolve(uploadAvg);
      } else {
        statusValue.textContent = 'Upload error';
        reject(new Error('upload failed ' + xhr.status));
      }
    };
    xhr.onerror = function() {
      statusValue.textContent = 'Upload error';
      reject(new Error('upload error'));
    };
    statusValue.textContent = 'Uploading...';
    xhr.send(blob);
  });
}

// full test orchestration
async function runFullTest() {
  if (running) return;
  running = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  dPoints = []; uPoints = []; dSamples = []; uSamples = [];
  clearCanvas(dctx); clearCanvas(uctx);
  downloadValue.textContent = '—';
  uploadValue.textContent = '—';
  downloadMeta.querySelector('.item') && (downloadMeta.querySelector('.item').textContent = 'avg: — Mbps');
  uploadMeta.querySelector('.item') && (uploadMeta.querySelector('.item').textContent = 'avg: — Mbps');

  // Ping
  pingValue.textContent = '–';
  const ping = await measurePing();
  pingValue.textContent = ping + ' ms';
  lastPing = ping;

  try {
    const dAvg = await runDownloadTest();
    // small pause
    await new Promise(r=>setTimeout(r,600));
    const uAvg = await runUploadTest();
    statusValue.textContent = 'Complete';
    // done
  } catch(err) {
    console.error('test error', err);
    statusValue.textContent = 'Error';
  } finally {
    running = false;
    startBtn.disabled = false;
  }
}

function resetTest() {
  abortController && abortController.abort();
  running = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  downloadValue.textContent = '—';
  uploadValue.textContent = '—';
  statusValue.textContent = 'Idle';
  pingValue.textContent = '— ms';
  dPoints = []; uPoints = [];
  dSamples = []; uSamples = [];
  downloadMeta.querySelector('.item') && (downloadMeta.querySelector('.item').textContent = 'avg: — Mbps');
  uploadMeta.querySelector('.item') && (uploadMeta.querySelector('.item').textContent = 'avg: — Mbps');
  clearCanvas(dctx); clearCanvas(uctx);
}

// UI bindings
startBtn.addEventListener('click', runFullTest);
stopBtn.addEventListener('click', resetTest);
stopBtn.disabled = true;
shareBtn.addEventListener('click', async () => {
  const out = `Download: ${downloadValue.textContent} Mbps\nUpload: ${uploadValue.textContent} Mbps\nPing: ${pingValue.textContent}`;
  try {
    await navigator.clipboard.writeText(out);
    alert('Results copied to clipboard:\n' + out);
  } catch {
    prompt('Copy results:', out);
  }
});

// responsive: redraw graphs on resize
window.addEventListener('resize', ()=>{ drawGraph(dctx,dPoints,'#6b7dff'); drawGraph(uctx,uPoints,'#7b4bff'); });

</script>
</body>
</html>
